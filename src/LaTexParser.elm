module LaTexParser exposing (..)

import Char
import Dict exposing (Dict)
import Lazy.Tree as Tree exposing (Tree)
import Lazy.Tree.Zipper as Zipper exposing (Zipper)
import List.Extra
import Parser exposing ((|.), (|=), Parser)
import Set


curlyBrace : Parser String
curlyBrace =
    (Parser.getChompedString <|
        Parser.succeed ()
            |. Parser.spaces
            |. Parser.multiComment "{" "}" Parser.Nestable
    )
        |> Parser.map String.trim
        |> Parser.map (String.dropRight 1)
        |> Parser.map (String.dropLeft 1)


infixOp : String -> Parser (Tree Operator)
infixOp str =
    Parser.succeed
        (Infix str
            |> Tree.singleton
        )


symbol : Parser Operator
symbol =
    Parser.succeed Symbol
        |. Parser.spaces
        |= Parser.variable
            { start = Char.isAlpha
            , inner = Char.isAlphaNum
            , reserved = Set.fromList []
            }


command : Parser LatexNode
command =
    Parser.succeed BackslashCommand
        |. Parser.spaces
        |= Parser.variable
            { start = (==) '\\'
            , inner = Char.isAlpha
            , reserved = Set.fromList []
            }



-- these are all things that end up in the equation tree and can be user defined.
-- Perhaps these are the only types that we need?
-- these are true operators that we are going to let the users define.
{--

"+" Infix left=1 right=1 Ascoceative Comunitave      Keyword "+" >> Parser for infix 
"\int" Infix 2                                       Keyword \int >> Parser for Postfix
"x" Symbol                                           Keyword "x" >> parser for symbol

then the whole expresion is a list of operators and then we can build up the tree

To resolve the infix operators we need the user to define the infix operator precedance

process the top first
()
exp()
*/
+-
=

now the tree can be built up
whew
This allows folks to build their own syntax and maintain their own library of syntax 

--}


type Operator
    = Infix String
    | Postfix String
    | Prefix String
    | Symbol String
    | Substitution String



-- we also need a way to represent arguments for the users
-- these are all things that are already defined in the LaTex syntax things like  \frac takes two args


type LatexNode
    = BackslashCommand String
    | SpaceSepCommand String
    | CurlyBraceArg String
    | SpaceSepArg String


type alias CustomOperator =
    { name : String
    , argsLeft : Int
    , argsRight : Int
    }


type alias OperatorLibrary =
    Dict String Operator


latexFromExpression : Zipper Operator -> String
latexFromExpression zip =
    case Zipper.current zip of
        Symbol str ->
            str

        Substitution str ->
            str

        Infix str ->
            Zipper.openAll zip
                |> List.map latexFromExpression
                |> List.intersperse str
                |> String.concat

        Postfix str ->
            Zipper.openAll zip
                |> List.map latexFromExpression
                |> String.concat
                |> (++) str

        Prefix str ->
            Zipper.openAll zip
                |> List.map latexFromExpression
                |> String.concat
                |> (\s -> s ++ str)


extraMerge : List a -> List a -> List a
extraMerge a b =
    List.Extra.interweave a b


merge : List a -> List a -> List a
merge x y =
    case ( x, y ) of
        ( hx :: tx, hy :: ty ) ->
            List.concat [ merge tx ty, [ hx, hy ] ]

        ( a, [] ) ->
            a

        ( [], b ) ->
            b



{--

operationDescriptionFromTree : Operation -> Zipper Operation -> String
operationDescriptionFromTree op =
    case op of 
        Infix string
    merge op.descritption op.args
        |> String.concat
--}
--- The library of syntax generated by the user -> List Node
-- then we need the tree manipulations to come out of the syntax
-- so what are the basic tree manipulations and how can we map between them?
-- prune, sprout,
{- parser GUI to make new latex commands. we can chian parsers
      together through steps

      but then we are just string safe and constrained to the
      KaTex library

      how can we keep the user control to make your own top level
      functions and have simple and expandable program structure

      are we writing our own programming language now?

      make a bunch of stuff for every katex symbol
      but let people make their own functions that use those

      is it helpful to ask people to make their own algebraic
      engine??

      Here's how I'd like to use it:
          start with an equation
              y=mx+b
          just say the command
          subtract b
              y-b=mx+b-b
          the first time we run a function like this we don't
          want to fully apply the subtraction
          evaluate b-b=0
              y-b=mx
          now define subtract to simplify if possible
          (thats a whole tree math thing like in sympy)

       do you just use a CAS like sympy as a backend or do you
       make your own? Sympy is verry clearly an object structured
       program. what would the functional equivelent look like?


       Or do you make a dumb cas and connect it to tree manipulations to
       allow others to use their own functions connect it to a solving step
       alpha thing though alpha is $0.10 per request ugh
       myscript handwriting recognition api calls are ~ $0.09



   -- "(3, 4)"


   point : Parser Point
   point =
       Parser.succeed Point
           |. symbol "("
           |. spaces
           |= float
           |. spaces
           |. symbol ","
           |. spaces
           |= float
           |. spaces
           |. symbol ")"

   -
-}
-- Type Latex
--     =
-- latexArgs : Parser Latex
-- latexArgs = Parser.succeed Latex Parser.multiComment "{" "}" Nestable
------------ Generic CAS functions -------------------
-- The string reperesents the LaTex syntax of each operator / symbol
