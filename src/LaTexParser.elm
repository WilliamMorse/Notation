module LaTexParser exposing (Point, point)

import Lazy.Tree as Tree exposing (Tree)
import Lazy.Tree.Zipper as Zipper exposing (Zipper)
import Parser exposing ((|.), (|=), Parser, float, spaces, symbol)


type alias Point =
    { x : Float
    , y : Float
    }


type alias LatexCommand a =
    { latex : String
    , parser : Parser Node
    , name : String
    }


type alias Equation =
    { lhs : Node
    , rhs : Node
    }


type alias Operation =
    { descritption : List String -- these stay static
    , args : List Zipper Node -- These change with the whims of the operation
    }


type Node
    = Infix String
    | Symbol String
    | Constant Float
    | Subsitution String
    | PostFix String


latexFromExpression : Zipper Node -> String
latexFromExpression zip =
    case Zipper.current zip of
        Symbol str ->
            str

        Constant number ->
            String.fromFloat number

        Subsitution str ->
            str

        Infix str ->
            Zipper.openAll zip
                |> List.map latexFromExpression
                |> List.intersperse str
                |> String.concat

        PostFix str ->
            Zipper.openAll zip
                |> List.map latexFromExpression
                |> String.concat
                |> (++) str


merge : List a -> List a -> List a
merge x y =
    case ( x, y ) of
        ( hx :: tx, hy :: ty ) ->
            List.concat [ merge tx ty, [ hx, hy ] ]

        ( a, [] ) ->
            a

        ( [], b ) ->
            b

        ( [], [] ) ->
            []


operationDescriptionFromTree : Operation -> String
operationDescriptionFromTree op =
    merge op.descritption op.args
        |> String.concat



--- The library of syntax generated by the user -> List Node
-- then we need the tree manipulations to come out of the syntax
-- so what are the basic tree manipulations and how can we map between them?
-- prune, sprout,
{- parser GUI to make new latex commands. we can chian parsers
   together through steps

   but then we are just string safe and constrained to the
   KaTex library

   how can we keep the user control to make your own top level
   functions and have simple and expandable program structure

   are we writing our own programming language now?

   make a bunch of stuff for every katex symbol
   but let people make their own functions that use those

   is it helpful to ask people to make their own algebraic
   engine??

   Here's how I'd like to use it:
       start with an equation
           y=mx+b
       just say the command
       subtract b
           y-b=mx+b-b
       the first time we run a function like this we don't
       want to fully apply the subtraction
       evaluate b-b=0
           y-b=mx
       now define subtract to simplify if possible
       (thats a whole tree math thing like in sympy)

    do you just use a CAS like sympy as a backend or do you
    make your own? Sympy is verry clearly an object structured
    program. what would the functional equivelent look like?


    Or do you make a dumb cas and connect it to tree manipulations to
    allow others to use their own functions connect it to a solving step
    alpha thing though alpha is $0.10 per request ugh
    myscript handwriting recognition api calls are ~ $0.09


-}
-- "(3, 4)"


point : Parser Point
point =
    Parser.succeed Point
        |. symbol "("
        |. spaces
        |= float
        |. spaces
        |. symbol ","
        |. spaces
        |= float
        |. spaces
        |. symbol ")"



-- Type Latex
--     =
-- latexArgs : Parser Latex
-- latexArgs = Parser.succeed Latex Parser.multiComment "{" "}" Nestable
------------ Generic CAS functions -------------------
-- The string reperesents the LaTex syntax of each operator / symbol
